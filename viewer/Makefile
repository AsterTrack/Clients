# To be used with GNU Make

# Overwrite compiler used
ifeq ($(COMPILER), clang)
CXX=clang++
CC=clang
LD=ld.lld
else ifeq ($(COMPILER), gcc)
CXX=g++
CC=gcc
LD=gcc
endif

# Set mode-specific options
ifeq ($(BUILD_TYPE), release)
# Very fast, but slow to iterate on, used for final deployment
# lto makes it faster to compile from scratch, but slower to iterate, as linking will do all optimisations
cmode = -O3 -DNDEBUG -DEIGEN_NO_DEBUG
mode = release

else ifeq ($(BUILD_TYPE), release-verify)
# Fast, can verify memory is handled correctly, useful for testing code while not sacrificing much performance
cmode = -O3 -g -DEIGEN_NO_DEBUG -fno-omit-frame-pointer -fsanitize=address -DLOG_MAX_LEVEL_DEFAULT=LTrace
ifneq '' '$(findstring clang,$(CC))' # clang
	cmode += -DLIBCXX_ENABLE_ASSERTIONS=ON -D_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS
else # gcc - may technically already break ABI, but doesn't matter for this project
	cmode += -D_GLIBCXX_DEBUG
endif
lmode = -fsanitize=address
mode = release-verify

else ifeq ($(BUILD_TYPE), debug)
# Slow, for step-through debug
cmode = -O0 -g -fno-omit-frame-pointer -fsanitize=address
lmode = -fsanitize=address
mode = debug

endif


# Setup compiler environment
src = source
sh = ../shared
dep = dependencies/sources
b = build
o = $(b)/$(CC)-$(mode)
cflags = -Idependencies/include -Idependencies/sources \
	-DGLEW_STATIC $(cmode) -ffunction-sections -fpic
cxxflags = $(cstd) $(cflags) -I$(src) -I$(sh) -I$(dep)/imgui -DEIGEN_MPL2_ONLY -D_FILE_OFFSET_BITS=64 \
	-Wno-deprecated-enum-enum-conversion \
	-D_UNICODE -DEIGEN_NO_AUTOMATIC_RESIZING -DEIGEN_INITIALIZE_MATRICES_BY_NAN \
	-DINTERFACE_LINKED \
	-std=c++20 -msse4.2 -mavx2 -mfma -ffp-contract=fast
lflags = -Wl,-rpath='$$ORIGIN' $(lstd) $(lmode)


# Define all source files to be compiled
SOURCES_CPP = \
	app.cpp client.cpp \
	io/vrpn.cpp \
	\
	ui/ui.cpp ui/menu.cpp \
	ui/protocols.cpp ui/logging.cpp ui/view3D.cpp \
	ui/gl/visualisation.cpp ui/gl/sharedGL.cpp \
	ui/gl/mesh.cpp ui/gl/shader.cpp \
	ui/imgui/imgui_custom.cpp ui/imgui/imgui_onDemand.cpp

DEP_CPP = \
	imgui/imgui.cpp imgui/imgui_draw.cpp \
	imgui/imgui_widgets.cpp imgui/imgui_tables.cpp \
	imgui/backends/imgui_impl_glfw.cpp imgui/backends/imgui_impl_opengl3.cpp \
	imgui/misc/cpp/imgui_stdlib.cpp \
	imgui/imgui_demo.cpp

DEP_C = GL/glew.c

OBJECTS_ALL = $(addprefix $(o)/,$(SOURCES_CPP:.cpp=.obj)) \
					$(addprefix $(o)/dependencies/,$(DEP_CPP:.cpp=.obj)) \
					$(addprefix $(o)/dependencies/,$(DEP_C:.c=.obj))
SOURCES_ALL = $(addprefix $(src)/,$(SOURCES_CPP)) $(addprefix $(dep)/,$(DEP_CPP)) $(addprefix $(dep)/,$(DEP_C))

# Find libraries
libdir = dependencies/lib/linux
vrpnlibs = $(libdir)/vrpn/libvrpn.a $(libdir)/vrpn/libquat.a
glfwlibs = $(libdir)/libglfw3.a
libs = $(vrpnlibs) $(glfwlibs) -lrt -lGL -latomic

all: checkLibs mkbuild $(b)/astertrack-viewer cpylib

# Make sure libraries are built
.PHONY: checkLibs
checkLibs:
	@test -d dependencies/include/vrpn || { echo "VRPN include files are missing (dependencies/include/vrpn)!"; }

.PHONY: mkbuild
mkbuild:
	@if [ ! -d $(b) ]; then mkdir $(b); fi
	@if [ ! -d $(o) ]; then mkdir $(o); fi

.PHONY: cpylib
cpylib:

# Generic compile targets
$(o)/%.obj: $(src)/%.cpp
	$(CXX) -MMD -MP $(cxxflags) -c $< -o $@
$(o)/dependencies/%.obj: $(dep)/%.cpp
	$(CXX) -MMD -MP $(cxxflags) -c $< -o $@
$(o)/dependencies/%.obj: $(dep)/%.c
	$(CC) $(cflags) -c $< -o $@

# Include header dependencies as generated by -MMD -MP
-include $(OBJECTS_ALL:.obj=.d)
$(shell mkdir -p $(dir $(OBJECTS_ALL)) >/dev/null)

# AsterTrack Client
$(b)/astertrack-viewer: $(OBJECTS_ALL) .FORCE
	$(CXX) -rdynamic -o $@ $(OBJECTS_ALL) $(libs) $(lflags)

# Always force re-link at least, since different modes share the same target
.PHONY: .FORCE
.FORCE:
